---
id: 20240502213900_5db4798d15a34652
date: "2024-05-02"
aliases:
- 第六部分 理解软件
- 第32章 测试的哲学
category:
- read
tags: 
tc:
- read
---

## 第32章 测试的哲学

也就是说一旦某个测试失败了，很有可能是我们的软件需要修改，而不是我们的测试。当然有时候我们也需要对测试进行修改来确保它能够恰当地反映我们软件当前的状态。

看上去这些与测试有关的调整会给人带来挫败感，也有浪费时间的嫌疑，但实际上这是能产生双向影响的科学方法论中，再正常不过的一个组成部分——有时我们会意识到测试有问题，有时我们的测试会告诉我们系统出现了需要修复的漏洞。

通过对测试的价值、断言、边界、假设和设计进行检视，有助于对我们编写的测试进行重新思考。现在让我们分别看看这五个方面。

测试的价值: **测试的目的在于向我们传递系统的有关知识，这些知识其实存在不同层次的价值。** 如果能让我意识到，即使我依赖调用的API做出了破坏性的修改，但我的代码依然能够正常工作，在这种情形下这部分信息还是能给我带来非常大的帮助的。总的来说：**在创建一个有效和有用的测试之前，人们必须要清楚地知道自己想要获得什么样的信息。**

测试边界: 每一个测试都存在一定的边界，这是作为测试定义与生俱来的一部分存在的。好比你不可能仅仅通过一个实验来证明所有的理论和物理法则是成立的，基本上也不可能通过单个测试来一次性地对任何复杂系统内存的所有行为进行验证。**所以当在设计测试时，你应该知道什么需要被测试，什么不需要。**

测试假设: 每一个测试内都存在一组假设，这是测试在它的边界内能够高效执行的前提。举例, 测试依赖数据库访问, 你或许需要假设数据库完成搭建并正常运行, 如果数据库没有运转起来，那么测试既不能算通过也谈不上失败——它无法向你提供任何信息。所以这一点告诉我们：**所有测试至少存在三种结果——通过、失败和未知。** 结果为“未知”的测试不能说它们是失败的——否则就意味着他们向我们提供了某些关于系统的信息，但事实上它们没有。

测试设计: 因为上面提到了的边界和假设，所以我们需要对全套的测试进行设计，以便：**当我们将所有的测试组合在一起后，它们能够切实给予我们想要获取的所有知识。**

**每一个独立的测试只能给予我们仅限于它的边界和假设内的有限知识，所以我们如何才能将这些边界交织在一起，以便它们能够正确地向我们展示整个系统的真实行为是什么样的呢？** 这个问题的答案或许会影响到正在测试的系统的架构设计，因为其中的有一些设计会比其他设计更难以测试。

端到端测试: **“端到端”测试的意思是对一条完整的系统逻辑“路径”进行断言**。也就是说你需要把整个系统搭建起来，在用户端执行一些操作，然后验证系统产出的结果。你并不关心系统内部为了达到这个目的是如何工作的，你只需要关心输入和结果。这基本上对所有测试都是成立的，但是在这里我们只在系统的最外层执行测试，也只检查最外层返回的结果。**端到端测试背后的主要思想是，通过我们尽可能以“真实”和“全面”的方式对系统进行测试，可以从断言中获取到极为精准的知识**。路径上所有的交互和涉及的复杂逻辑都用测试进行覆盖。

集成测试: 在这种测试场景下，你会取系统中的一个或者多个完整“组件”，用于专门测试将它们“组合在一起”后的表现行为如何。这里说的一个组件可以是一个代码模块、一个你系统依赖的库、一个提供数据的远程服务——本质上来说系统内任何一个从概念上可以和系统其他部分分离的内容都可以算作是一个组件。与端到端测试相比，集成测试会将有待测试的组件独立出来，而不是把整个系统想象成一个“黑盒”对其进行测试。

单元测试: 在这个测试场景中，你需要单独选取一个组件，然后独立地对它的行为进行测试。在我们上面创建账号的例子中，我们可以编写一部分用于验证账号创建的相关代码的单元测试，以及一部分独立的用于验证发送邮件的代码的单元测试，还有一部分独立的针对用户填写页面上账户信息行为的一些单元测试等。**通常来说一个单元测试只会对一个类/模块中一个函数的单个行为进行验证。** 只有当系统的组件在划分合理，以及简单到能够对行为做出完整定义的情况下，单元测试才能发挥出最大的功效。

> [!NOTE]
> 这三个测试的主要区别是什么呢? 可以理解成具体的测试代码行数吗? 三个测试的行数在不断变多, 可能的状态在变多.
> 真的可以准确对一个测试进行三种划分吗? 我认为无法准确划分, 是一个很宽的广谱.

真实情况: 现实世界里，在端到端测试和单元测试之间还存在不计其数的中间态测试类型。有时候你的测试方案介于单元测试和端到端测试之间。有时候你的测试又介于集成测试和端到端测试的交集当中。实际的系统会依赖所有形式的测试类型，用于帮助人们正确地理解系统行为。

伪造数据:
1. 为每一个独立组件都编写一份测试的好处在于，当系统发生更改时，相比集成测试和端到端测试的更新，单元测试的更新要少得多。如果你为了让测试里的组件相互独立而让测试变得复杂，那么这种复杂性会抵消上面所说的优点，因为你需要添加更多的测试代码来让测试处于一种最新的状态。
2. **一个组件和它内部依赖的关系通常是非常复杂的，如果你测试的不是它的真实依赖，那么你有可能测试到的不是它的真实行为**。当开发者没能成功让“伪造的”数据与真实数据保持一致时，这种情况就会发生，但当试图“伪造”一个与“真实”对象具有相同功能和相同复杂度的对象失败时，这种情况也会发生。
3. **如果一个测试中新增的“伪造”对象太多的话，这种现象很可能在暗示系统的设计存在问题，应该通过修复系统代码来解决，而不是在测试中“绕过”这个问题。**

总而言之，测试之间存在“相互重叠”的部分不能算是坏事。比如现在你有一个与用户代码的公共API有关的测试，同时还有一个与邮件发送代码的公共API有关的测试。

通过“伪造数据”来对代码进行隔离在某些时候还是有用的。但人们必须要谨慎地作出决策，以及小心背后产生的成本，同时还需要通过对“伪”实例进行有意识的设计来缓解它们带来的副作用。值得注意的一点是，伪造数据还是能给我们的测试带来两方面的提升——确定性和速度。

确定性: 如果系统或者它所处的环境中不存在任何变数，那么测试的结果也应该不会发生任何变化。如果系统中的一个测试今天能够通过，但是在没有对系统做任何修改的情况下明天却失败了，说明这个测试是不可靠的。**事实上该测试应该算是无效的，因为它的“失败”并非真的失败，而是“未知”的结果伪装成了有效知识。我们还可以说这种测试是“碎片化”或者是“不确定的”**。

覆盖率: 有一些工具能够在运行测试的情况下告诉你系统的哪些行代码被测试运行过了。它们将这个称为系统的“测试覆盖率”。这些工具有时候确实很有用，但是需要特别记住的是，它们其实并不会告诉你那些代码是否真的被测试过了，只是运行过而已。如果对代码行为没有执行过断言，那么它就算不上被测试过

测试的总体目标: 有非常多的方式来获取有关一个系统的相关知识，测试只是其中的一个渠道。我们也可以采用阅读代码、浏览文档、和开发者交谈等方式达到同样的目的，其中的每一种方式都能给予我们关于系统行为的简要概况。但是，测试恰恰可以对我们获得的这些简要信息进行验证，所以它在所有这些方法中才显得特别重要。**测试的总体目标是获取关于系统的有效知识。**

但有的测试方法会比其他测试方法运行的效率更高：它们可以使我们更轻松地创建和维护那些，能够产出我们想要的所有信息的测试。这些方法应该被吃透，以及被恰当地利用起来——你可以决定什么时候该使用这些方法，以及如何将它们用于你正在测试的特殊系统。

> [!NOTE]
> 我们可以将单元测试理解成对接口的一种特殊注释, 这个注释可以让计算机进行验证操作; 这个注释是给计算机看的, 或者注释对计算机更重要, 而不是对人.
> 实现代码的时候完全可以实现两份满足相同需求的代码, 这两段代码互为测试逻辑, 互相进行验证对方的正确性.
> 所以单元测试表达的知识可以理解成"是对接口中注释的程序化表述".
> 如果测试是接口的程序化表述, 那注释应该记录的是无法写成测试的部分.