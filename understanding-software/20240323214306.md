---
id: 20240323214306_17921ebdbd304a44
date: "2024-03-23"
aliases:
- 第三部分 简约与软件设计
- 第9章 设计要从头抓起
- 第10章 预测未来的准确度
- 第11章 简约与严格
- 第12章 两遍已太多
- 第13章 健壮的软件设计
category:
- read
tags:
tc:
- read
---

## 设计要从头抓起

你需要从一开始就着手于软件设计，应该从立项之初就致力于将架构设计得简约明了。对于我全权负责的项目，我们的开发策略是，除非架构设计支持轻松地将该功能实现，否则我们绝不允许新增该功能。

最糟糕的情况是，在你允许人们在几个月或几年内不经过提前设计就往代码中新增功能，然后有一天你幡然醒悟并意识到系统有可能撑不住了。此时你唯一的选择只能是修复整个代码库。这注定会是一项艰巨的任务，因为就像新增功能一样，它无法一气呵成，除非你想要重写整个应用。

> [!NOTE]
> 维护过的最大的仓库代码也就 10w 行左右, 很好奇随着代码项目的增大, 还能做到吗?

## 预测未来的准确度

在软件设计领域中，我们都同意对未来做出适当的判断非常重要。但我们也知道未来是很难预测的。我认为我已经想到了一个理论，恰好能用于解释为什么预测软件的未来如此困难。

这个理论的基础版本是：**预测未来的准确度，会随着系统复杂性和预测点距今时间跨度的增加而降低。** 也就是说随着系统变得越来越复杂，你只能以有限的准确度预测短时间范围内的未来。反之随着系统变得越发简单，你越能以高准确度预测较远的未来。

在现实工作中，存在一种基于以上准则扩展之后的逻辑先后关系：

1. 预测未来的难度会随着系统和被预测功能所处环境内，所有修改之处数量总和的增长而增加。（注意，环境带来的影响与它和系统的逻辑距离成反比。如果你的系统与汽车有关，那么对引擎的修改可能会给系统带来非常大的影响，但是对环境内某棵苹果树的修改带来的影响则微乎其微。）
2. 系统需要经受的修改与系统的整体复杂性相关。
3. 所以：预测变困难的速率会与被预测行为所属系统的复杂性成正比。

> [!NOTE]
> ![[20230101152735|架构是面向未来的赌博]]

当我们只关注当下，关注我们已有的数据，关注我们现有的软件系统，相比预测我们的软件在未来何去何从，我们更容易做出正确的决定。大部分在软件设计中犯下的错误来自假设未来需要做些什么（或者完全不需要做些什么）。

## 简约与严格

**一个普适的原则是：你的应用程序对编码要求越是严格，就越易于编写。**

总而言之，我坚持认为计算机永远不应该“猜测”或者说“尽全力满足”用户的输入。由此引入的噩梦般的复杂性会导致程序极易失控。猜测唯一能恰如其分发挥功效的地方是内置于类似于谷歌网站的拼写建议功能中。它提供你做事情的选项，但不会一股脑地基于猜测的结果去完成工作。这也是我在谈论严格时想强调的另一个方面，输入要么是对要么是错，不存在“也许”这种情况。如果一个输入有可能包含多层含义，要么你应该为用户提供选项，要么直接报错。

> [!NOTE]
> 可以理解成鼓励多使用"断言", 不要任何输入都有相应.

## 两遍已太多

**当我在做增量开发和软件设计时，我个人会遵从一条关键原则，我称之为“两遍已太多”**。这条原则描述的是我如何在实际工作中落地另一条原则，也就是我在《简约之美》中所说的“**代码只在必要时才需要通用**”。

我留意到自己通常在剪切粘贴代码之际，会转而尝试设计通用方案来解决这两个操作背后的实际需求。这意味着本质上我对代码需要达到的通用程度是非常了解的。一旦我意识到自己正打算将同一份功能实现两遍时，就会开始执行这个步骤

> [!NOTE]
> 通常是我三遍才会开始这个步骤, 当然也可能会实现一个简单的代码生成器.

在重构过程中考虑 [[the_dry_principle|DRY 原则]] 和 [[the_single_responsibility_principle|单一职责原则]]

“两遍已太多”并不是一则简单粗暴的通用定理。它更类似于在增量开发时，指导我做出设计决策的参考标准。但同时它对重构遗留系统、开发新系统或者只是提升代码的简约性也非常有效。
