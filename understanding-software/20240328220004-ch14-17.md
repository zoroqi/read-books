---
id: 20240328220004_260e912b1e8642e3
date: "2024-03-28"
aliases:
- 第四部分 调试代码
- 第14章 什么是bug
- 第15章 bug的源头
- 第16章 确保它不会再发生
- 第17章 调试代码的基本哲学
category:
- read
tags:
tc:
- read
---

## 什么是bug

当谈论bug时我们究竟谈论的是什么？这里是关于bug的精确定义：

1. 程序的行为并没有符合程序员的预期。
2. 程序员的预期没有满足绝大部分**理性用户**的期望。

> [!NOTE]
> 第一个标准相对好判断, 比如 #TDD 就是基于这种观念来提高代码质量的.
> 第二个标准就很难判断了, "理性用户"占比很多吗? 就像经济学中的"理性人假设";
>     同样这个判断条件可滑坡成产品或 Boss 脑中的期望;
>     当然书中的提到的主要用户也是程序员, "程序员"应该符合"理性用户"假设.

## bug的源头

bug通常来自开发者尝试降低代码复杂性未果而产生的副作用。也有部分来自对其实简单的代码产生的误解。

> [!NOTE]
> ![[premature_optimization_effect|过早优化效应]]

**一旦代码的意图和使用方法变得极不明确，就会让使用这份代码的人犯错。又因为你的代码和其他的代码混合在了一起，导致了开发者误用和犯错的可能性大大增加。而后这些代码又会继续和其他的代码混合，形成恶性循环。**

所以最后可以总结出几条有趣的原则：

1. 你写的代码越简单，bug就越少。
    > 所以有一个伟大的项目 [kelseyhightower/nocode](https://github.com/kelseyhightower/nocode)
2. 你应该始终想方设法去简化程序中的代码。

## 确保它不会再发生

当你在解决代码中的问题时，你不应该止步于只修复问题表象。而是应该确保问题彻底消失并且永远不会再发生。

> [!NOTE]
> ![[201910010001|每次打开一个源码文件，你都应该让它变得更好]]

我职业生涯的大部分时间要么是在从无到有地设计具有可拓展性的开发代码，要么在将糟糕代码库进行重构。无论代码库多么糟糕，你总能解决它其中的各种问题。但前提是你必须了解软件设计的相关原理，拥有足够的人力，以及务必以确保它们不会再次发生的态度解决问题。

衡量一个问题是否被真的解决的恰当标准是：在大部分实际情况中，你能做到的是当下不会再有人被这个问题困扰，但是并不代表问题在未来不会再次出现。

除此之外，如果你富有探索精神，还可以提出更多的问题：为什么开发者会写出错误代码？bug为什么会存在？是开发者接受的技能培训出了什么问题？还是工作的流程中存在纰漏？他们在编写代码的同时是否也应该编写测试？会不会是系统的设计缺陷导致代码难以修改？编程语言过于复杂了？他们用的类库编写的不够友好？操作系统出了什么问题？文档描述得不够清楚？
如果你有了关于某个问题的答案，你可以继续思考产生这个问题的根本原因又是什么，并且持续追问下去直到你所有的诱惑都已经解开。但是请小心：你并不知道这一串问题的终点在哪里，甚至整个过程会颠覆你对软件开发的看法。事实上从理论上来说，在这一套方法论下可以提出无限多的问题，并且终将让整个软件行业的根本问题得到解决。但是在这条路上要走多远还是取决于你自己。

> [!NOTE]
> 我对这个问题的答案是, 因为"人"的多样性, 当没有多样性的时候自然就不会这些bug.
> 当然另一个次要的原因是, 这个世界本身并不是 100% 确定, 程序世界只有 0 和 1, 但是这个世界存在了太多中间状态.

## 调试代码的基本哲学

首先回到调试代码流程本身，正确的做法应该是什么？猜测是在浪费时间，设想出错原因也是浪费时间——基本上在遇到问题的第一时间内，你脑海中冒出的想法都属于无稽之谈。此时此刻你需要了解的只有两件事：
1. 记住系统正确的行为是什么。
2. 想清楚应该通过追踪哪一部分代码来收集更多的有效信息。

这些就是调试代码的四个主要步骤：
1. 熟悉正常工作的系统行为应该是什么样的。
2. 接受其实你并不知道问题原因的这个事实。
3. 追踪代码直到你找到问题的原因是什么。
4. 修复根本原因而不是表面症状。

> [!NOTE]
> 和我的调试基本不一致, 我很少去确定正常行为是什么, 我首先是找到稳定复现问题的方式, 之后在去理解正常的行为.
